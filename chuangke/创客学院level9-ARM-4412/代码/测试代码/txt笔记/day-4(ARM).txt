1.ARM硬件操作
  ARM的硬件能工作<-----寄存器(控制器+数据寄存器)---------->都是程序控制实现的！
  
2.过程
   
  (1).确定要操作的硬件
  (2).到原理图上寻找(底板)
  (3).分析和了解硬件的工作原理(相关的引脚需要什么样的电平)
  (4).需要电平控制的引脚 与 CPU的引脚的关联 (找到CPU的控制引脚)
  (5).如何控制CPU的引脚，实现我们想要的电平？
 loop:
  --------------------------------------------------------------
  (6).查看相关的datasheet 阅读了解(overview)
  (7).找到相关的章节进行阅读了解
      a.非寄存器描述(主要是介绍相关接口的信息)
	  b.寄存器描述(主要介绍,操作对应的接口实现想要的功能时，要用到寄存器)
      
   例子:
      led 灯
   (a). 相关寄存器:
      GPX2CON ----(要用)
      GPX2DAT ----(要用)
      GPX2PUD ----(暂时用不到)
      GPX2DRV ----(暂时用不到)	  
   (b). 分析要用到的寄存器的设置 ---(什么样的状态)
      GPX2CON ----(要用) 
	  功能:
	      选择引脚功能
	  设置:
	      控制的是GPX2_7 这个引脚 ---要作为输出
		  GPX2CON[31:28] = 0x1;
		    [功能]
			0x0 = Input
			0x1 = Output（*）
			0x2 = Reserved
			0x3 = KP_ROW[7]
			0x4 = Reserved
			0x5 = ALV_DBG[19]
			0x6 to 0xE = Reserved
			0xF = WAKEUP_INT2[7]

      GPX2DAT ----(要用)
	  功能:
	       作为输出时，对应的GPX2DAT中的某一位的值 直接影响的就是引脚的状态！
	  设置:
	      控制的是GPX2_7 这个引脚 ---输出高电平
		  GPX2CON[7] = 0x1;
 ----------------------------------------------------------------------- 
  (8).编程进行操作(asm - c )
  
    汇编描述一下地址:
	 
	.equ GPX2CON , 0x11000C40 @//[选择输出功能]
	.equ GPX2DAT , 0x11000C44 @//[控制输出电平] 
 
     ldr r0, =GPX2CON
	 //配置GPX2CON[31:28] = 0x1;
     ldr r1,=GPX2DAT	
     //在GPX2DAT[7]	= 1;
	 

  (9).不太可能一次性写好！(问题)
   b  loop  
-----------------------------------------------------------------------------

[Makefile]
<目标>: <依赖>
 <TAB> 生成目标的指令
 
 
[3].将.elf文件转换为 .bin的文件 
   a.命令行 
    arm-none-eabi-objcopy -O binary test.elf test.bin
   b.命令行 执行 Makefile
   c.keil 中执行make
     "Target Options"----> User ---->"Run User Programs Before Build Or Rebuild"
	 下面指定 make	 
 -----------------------------------
 
 练习:
     通过key2实现对灯的控制！
	 
---------------------------------------
按键控制:
(1).检测电平(轮询方式)
(2).中断方式
   
   a.中断的概念
   b.中断过程
     (中断源，中断服务程序)
   -------------------------
   ARM体系结构的中断
   [单CPU]
               /--->IRQ\
	GPIO ----->|        |===>|ARM Core|
	           \--->FIQ/
   [多CPU]
                       /--->IRQ\    |----ARM Core0
	GPIO ----->[GIC]-->|       |===>|----ARM Core1
	                   \--->FIQ/    |----ARM Core2
					                |----ARM Core3
									
   ------------------------------------------------
   配置:
   [1].GPIO相关的配置(设置为中断的功能)
   [2].GIC配置	 
   ------------------------------------------------
   配置:
   [1].GPIO相关的配置(设置为中断的功能)
       //(1). muxed  ---选择为中断功能
       GPX1CON[4:7] = 0b1111 //0xF = WAKEUP_INT1[7] 0x1100_0C20 
	   //(2).引脚关于中断的配置
	   // falling
       EXT_INT41_CON[4:6] = 0b010        //  0x1100_0E04
	   //(3).使能中断
       EXT_INT41_MASK     = 0x0 ;        //  0x1100_0F04
	   //(4).清除中断时用   写"1"表示清除
       EXT_INT41_PEND  	   = 0x1;       //0x1100_0F44
       
   [2].GIC配置	 
   
      //(1).enable for distributor      //
	  ICDISER1_CPU[25] = 0b1         //0x1049_0104
      ICDDCR[0] = 0b1                //0x1049_0000
       
	  //(2).target cpu0
       ICDIPTR14[8:15] = 0b1         //0x1049_0838   (57除4 商 14 余1) --一个字节控制一个中断
	   
      //(3).mask priority ----0xff 最低优先级的值
      ICCPMR_CPU0[0:7] = 0xff        //0x1048_0004
     
	  //(4).enable for cpu0 interfacex
       ICCICR_CPU0[0] = 0b1          //0x1048_0000
	  
      //(5). no secure
      ICDISR1_CPU0[25] = 0b1         //0x1049_0084
	  
	  
	  //(6).清除操作
	  ICDICPR1_CPU0[25] = 0b1       //0x1049_0284
	  ICCEOIR           = cpuid | irq_num(ICCIAR_CPUn)  //0x1048_0010
 
  [3].实现异常向量表
  [4].异常处理函数 
      
      
  