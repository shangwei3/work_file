共享资源 : 任何人都可以访问的资源
临界资源 : 同一时刻只能有一个人访问，如果多个人访问就会有问题
临界区   : 访问临界资源代码称为临界区

执行单元 : 进程代码、中断处理函数
多人同时访问就会出现并发，如果并发执行，必定会产生竞态

如果并发执行的时候，有问题，我们必须对并发就行处理，处理之后效果:同一时刻只有一个人访问 

问:如果我们只让一个执行单元去访问，其他的执行单元怎么办？
答:<1>一直尝试获取访问共享资源资格
	 <2>为了节省消耗，其他执行单元进行睡眠
	 <3>其他执行单元直接返回，放弃访问共享资源,先去做其他的事情，然后再去访问
	 
	 
并发的情况:
<1>进程与进程
<2>进程与中断
<3>中断与中断


中断屏蔽的手段:
<1>进程与进程之间并发(单CPU上可以控制，多CPU不行)
进程在访问共享资源的之前，它将中断关闭,此时不会有进程抢占它，也不会中断打断它(单CPU有效)。

<2>进程与中断(可以)

<3>中断与中断
	 中断处理函数在访问共享资源之前，将中断屏蔽，此时没有其他中断可以打断它了
	 

自旋锁 : 只有获得自旋锁的执行可以访问共享资源，没有获得自旋锁的执行单元,不断的尝试获得自旋锁

<1>进程与进程并发
	 单CPU:
	 一个进程获得自旋锁的时候，关闭了抢占，其他进程不能抢占它，此时只有它一个人访问
	 
	 多CPU:
	 此时多个CPU上的进程，只能有一个进程可以获得锁，其他进程无法获得锁
	 
<2>进程与中断 (不可以)

<3>中断与中断 (不可以)
   在中断的上半部处理函数使用时没有问题(此时其他中断时屏蔽的)
   

注意:在持有自旋锁的过程中不能有休眠的操作(例如:不能放弃cpu,不能调用引起休眠的函数)
   

互斥锁: 只有持有锁的执行单元可以访问共享资源，没有获得互斥锁的执行的单元进行休眠

<1>进程与进程并发(可以)
<2>进程与中断(不可以奇)
<3>中断与中断 (不可以)
   
   




一、进程调度

A进程时间5ms 

时间中断时1ms产生一次中断

时间中断(TIMER TICK) ->(定时器,...) [隔一段时间产生一个中断]

100HZ/1000HZ

handler_tick:
	[1]当前进程时间片的计数器值 + 1 
	[2]如果发现时间片到达，调度别的进程执行
	

运行队列:(有时间片，进程状态:TASK_RUNNING)
--------------------------------------------------------------
	B     C      D
--------------------------------------------------------------	

过期队列:(时间片用完)
--------------------------------------------------------------
 A  
--------------------------------------------------------------

如果运行队列空:将过期队列与运行队列角色转换,重新分配时间片


等待队列:(等待条件,进程状态:等待态(可中断与不可中断))
--------------------------------------------------------------
x   y   z 
--------------------------------------------------------------

注意:其他地方一定有唤醒进程的函数

二、可强占与不可抢占

抢占:不运行当前进程，而调度其他进程运行 

(1)用户态抢占
  [1]系统调用返回用户态
  [2]中断到来，打断用户态进程执行,中断返回
  
(2)内核态抢占
  [1]支持抢占   ->可抢占式内核 [>Linux 2.6]
  [2]不支持抢占 ->当进程在内核态的时候，会一直执行，直到它返回
	
---------------------------------------------------------------------------
内核态抢占,需要看的标志:
  [1]need_resched : 1 
  [2]preempt_count: 0
  
注意:在内核空间使用锁(自旋锁)的时候，会将preempt_count ++ 

内核态抢占，时机:
  [1]中断返回内核态，Linux操作系统会检查是否可抢占
  [2]内核态进程阻塞或自己调用了schedule()函数
  [3]释放锁(spin_unlock:会将preempt_count --)
--------------------------------------------------------------------------	


效果:我的LED设备只允许一个进程访问,其他进程打开LED设备的时候，失败

问题:如何知道，这个LED设备正在被别人使用?



int flag = 0;

xxxx_open()  
{
	if(flag == 1){
		return -EBUSY;
	}else{
	    flag = 1;
	}
}

ldr r0,[addr];  swp:对内存地址读操作的时候，同时可以向内存中写值
								mov r1,#1
								swp r0,r1,[addr]  解释:r0= *addr && *addr=r1  无论以前的地址中值是什么，最后一定是1
cmp r0,#0   A进程--------------------------------------->B进程

...                                                      ldr r0,[addr] =>  swp r0,r1,[addr]  r0= *addr && *addr=r1 
                                                         cmp r0,#0 //比较成功
                                                         打开成功
A进程打开成功 <----------------------------------------









   
用户态
--------------------------------------------------------------------
内核态
											    int  user_count = 0;
				
				
															int xxx_open()
															{
																	spin_lock();
																	
																	if(user_count != 0)
																	{
																			return -EBUSY;
																	}
																	
																	user_count ++;
																	
																	spin_unlock();
																	
																	return 0;	
															}
	


 
 
 
 A                                                             B进程没办法获得锁（锁被A占用，只能自旋）
 加锁
 ldr r0,[addr]
 cmp r0,#0
 释放锁------------------------------------------------------->B进程继续执行，此时user_count已经发生变化 
 
 思考:如果是单CPU,A进程在内核空间使用自旋锁,B进程会被调度运行吗? A进程会一直运行,B 进程不会运行
      如果是多CPU,A进程在内核空间使用自旋锁,B进程会被调度运行吗? A进程会运行，B进程也会,B进程会自旋
      
三、  自旋锁

单CPU平台:自旋锁功能只是关抢占
多CPU平台:内核空间关抢占  +  标志(V)

使用自旋锁目的?
防止多个执行者同时访问共享资源


进程与进程  ->OK 
进程与中断  ->进程在使用共享资源的时候，还需要关闭对应的中断
中断与中断  
A中断处理函数使用自旋锁，B中断优先级高，抢占A中断，并且也使用自旋锁,此时会出现什么情况?
此时B进程会一直自旋下去

如何避免中断之间并发?
中断处理函数执行的时候，关闭IRQ异常(等价于所有的中断都关闭)
                                                    

四、并发控制机制总结

并发控制效果:只有一个执行单元访问共享资源

执行单元(进程、中断处理函数)

(1)进程与进程
(2)进程与中断
(3)中断与中断 

自旋锁:
关抢占、没有获得锁的执行单元不会休眠，一直自旋 

用于:进程与进程

注意:自旋锁在使用的过程中，不能有引起进程休眠的函数

信号量:
没有获得信号量的进程，会休眠

进程与进程

互斥锁:
没有获得互斥锁的进程,会休眠 ,但是它实现效率比信号量高

原子操作:本质是一个变量，但是在这个变量的值在修改的过程中是不会被打断的，是一种原子操作

