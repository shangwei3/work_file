1.问:在Linux系统中，如何才能让我们的i2c从设备正常工作?
  答:
  	 <1>i2c 控制器的驱动
  	 <2>i2c 从设备的驱动
  	 	  第一种情况:
  	 	  使用Linux内核中提供的通用的从设备驱动(i2c-dev.c)
  	 	  
  	 	  第二种情况:
  	 	  程序员自己根据从设备编写从设备驱动
  	 	  
2.问:Linux系统系统中，i2c-dev.c号称是通用的从设备驱动，它是如何做到通用的呢?
	答:
		这个驱动在加载的时候，它会为Linux系统中，已经注册的i2c控制器设备生成一个设备文件
		(主设备号:89,次设备号:i2c控制器的编号)。
		疑问:i2c控制器设备是什么时候添加到Linux系统中的呢?
		回答:i2c控制器驱动加载的时候,它的probe函数执行的时候，添加了i2c控制器设备到Linux系统中。
		
		i2c-dev.c实现的从设备驱动中，并不包含实际的从设备操作方法。它只是在应用层给程序员提供了
		一个设备文件，通过这个设备文件可以找到特定i2c控制器设备。这样我们就可以在应用层根据
		特定的从设备，操作i2c控制器，从而控制从设备。
				
		
3.问:如何通过i2c-dev.c的通用从设备驱动操作i2c从设备?
	答:
		 第一步:
		 		我们需要确定从设备是由那个i2c控制器控制
		 		例如:
		 			  mpu6050是由i2c-5控制器
		 
		 第二步:
		 		通过i2c控制器的设备文件，找到i2c控制器
		 		
		 		例如:
		 			  fd = open("/dev/i2c-5",O_RDWR);
		 			  
		 			  
		 第三步:
		 	  我们需要将i2c从设备的信息，发送给i2c控制器，然后i2c控制器收到从设备的信息后，
		 	  解析从设备的信息，从而发出i2c总线时序，和i2从设备通信。
		 	  
		 	  
		 	  问:i2c从设备的信息，如何发送呢?
		 	  答:
		 	  	 在Linux系统中，i2c从设备的信息，存放在i2c_msg的结构体中。我们只需要将i2c_msg这个结构体
		 	  	 发送到i2c控制器就可以了。
		 	  	 
		 	  
		 	  问:如何填充i2c_msg这个结构体?
		 	  答:
		 	  	<1>从机地址
		 	  	<2>读写标志位
		 	  	<3>数据的长度
		 	  	<4>数据存放的地址
		 	  	
		 	  
		 	  问:具体发送几个i2c_msg结构体呢?
		 	  答:
		 	  	 这个需要根据i2c从设备的操作时序来确定，一个开始信号，对应i2c_msg。 
		 	  	 
		 	  	 
		 	 例如:
		 	 我们需要从mpu6050这个从设备中，读取它采集的温度,而mpu6050采集好温度数据之后，将温度数据
		 	 存放在了它内部的寄存器中。我们如果需要读取温度，那就必须要告诉mpu6050寄存器的地址，然后
		 	 mpu6050才会将寄存器中存放的数据发送给我们。
		 	 
		 	 char rx_data[1];
		 	 char tx_data[] = {0X42};
		 	 struct i2c_msg msg[2];
		 	 struct i2c_rdwr_ioctl_data ioctl_data;
		 	 
		 	 msg[0].addr  = 0x68;
		 	 msg[0].flags = 0x0;//写
		 	 msg[0].len   = 1;
		 	 msg[0].buf   = tx_data;
		 	 
		 	 msg[1].addr  = 0x68;
		 	 msg[1].flags = 0x1;//读
		 	 msg[1].len   = 1;
		 	 msg[0].buf   = rx_data;
		 	 
		 	 ioctl_data.msgs  = msg;
		 	 ioctl_data.nmsgs = sizeof(msg)/sizeof(msg[0]);
		 	  
		 	 ret = ioctl(fd,I2C_RDWR,&ioctl_data); //发送i2c_msg
		 	 
		 	 
		 	 return rx_data[0];
		 	 	  	 	 
		 	  	 
		 	  	 
		 	  	 
4.如何给予i2c总线，编写从设备驱动呢?

(1)填充结构体
	 i2c_driver
	 	 	  	 		
	 	 	  	 		
	 static const struct i2c_device_id mpu6050_id[] = {
			{ "mpu6050", 0 },
			{ "mpu6060", 0 },
			{}
	};

MODULE_DEVICE_TABLE(i2c,mpu6050_id);

static struct i2c_driver mpu6050_driver = {
	.driver = {
		.name = "mpu6050",
	},
	.probe = mpu6050_probe,
	.remove = mpu6050_remove,
	.id_table = mpu6050_id,
};
module_i2c_driver(mpu6050_driver);	 	  	

(2)实现probe函数
   static int mpu6050_probe(struct i2c_client *client,
				   const struct i2c_device_id *id)
				   
	 {
	 			//获取资源
	 			
	 			//注册字符设备
	 } 			   		