
夏万秋
ARM体系结构
	1、硬件、
		（1）、硬件原理 看电路图（符号，逻辑）  芯片手册
	2、嵌入式课程入门课程
	3、是重点，也是难点

	4、学习要求：
		1、侧重操作，问题出现的概率大，解决问题，细心耐心，多操作，多实验
		2、笔记，
		3、及时提问

第一天：
ARM汇编：
了解cpu如何运行软件？

计算机系统构成：
软件
硬件   了解
	1、输入型设备
	2、输出型设备
	3、存储设备
		硬盘   大 	价格便宜     慢     数据不易失
		内存   中   中 			 快		掉电数据丢失
		cache  高速缓存   容量小  贵
			一级  二级   三级
	4、处理器    G HZ  CPU    微控制器   SOC 
		CPU核
			运算器
			控制器
			寄存器   用户接口
	5、总线
		总线    各个部件间数据传输的公共通道
				单总线结构
				多总线
				
预备知识：
	
	约定 数的BIT位  从0开始数  

1、位运算： &  |   ~    <<  >>   ^
	a = 1111 0000 
	b = 0000 0001 
&:   a & b       
	与：同为真  结果为真  否则为假
		与0得0 与1 不变
将a第3位取出    0  1 
    (a & 0000 1000)  0x 08 ? 1<<3

	
	a = 0000 1111     0000 0111
将a数3位设置为 0   
	
	a = a &  1111 0111    
	
|：
	a = 1111 0000
将a数3位设置为 1 
	或1得1  或0 不变
	
	a |  0000 1000 
	
~：按位取反
	
	~a   0000 1111 
	
	
	a = 1111 0000

逻辑左移
<<：  a << 1   1110 0000        
	
逻辑右移	
>>:   a >> 1   0111 1000
	
	寄存器：不单是存储数据， 而是有特定的物理意义
	
	a =******** ***1**** ******** **** ****
	a[20]   1
	
	a | (1 << 20)
	
	a =******** ***0**** ******** **** ****
	a[20]   0
	
	a &   ~00000000 00010000 00000000 00000000
	
	a = a & ~(1 << 20)
	
	a[19:16]      1001
	
	a = a &  11111111 11110000 11111111 11111111
	  = a  &  ~00000000 00001111 00000000 00000000
			   00000000 00000000 00000000 00001111  0xf
			   
			   ******** ****0000 ******** ********
			   00000000 00000000 00000000 00001001
	a = (a  &  ~(0xf << 16)) |  (0x9 << 16)
			
			
			******** ****1001 ******** ********
	
	将任意一个数 任意连续位 设置为特定值 其他位保持不变
	
	
	某数b  [19:17]   设置为 101

	b = (b  & ~(0x7 << 17 )) | (0x5 << 17);
	
^:
	相同同为0 不同为1
	
	取反某些指定位。
	
	b [19:17]  取反： 
	
	10****** ****010* ******** ********
	00000000 00001110 00000000 00000000 
	
	10****** ****101* ******** ********
	b ^ ( 7 << 17 );

ARM CPU结构：

	寄存器：
		硬件给软件的接口。
	
CPU 寄存器： 
	cpu模式：变态，（cpu状态的改变,不同的状态对应不同的模式）
	安全性，处理异常
	每一种模式。都可以有18个寄存器可以操作（可见的） 除了usr模式有17个

ARM 共有37个寄存器。  Cortex  Monitor  40

了解：	
	芯片： 
		ARM7  9  11    32位CPU
		Cortex-M    M0  M3    低端的CPU  控制   有模式
		Cortex-R    R4        实时应用方面      实时操作系统
		Cortex-A    A8  A9（S3C2440）  A53      多媒体

ARM系列处理器：
	r0 - r12  通用寄存器。  32位宽度
	r13  栈指针寄存器  (SP)     存放栈顶指针。栈 
	r14  链接寄存器    (lr)     保存PC的值，在程序跳转之前
	r15  程序计数器    (PC)     保存当前程序运行的位置，下一条执行的指令  取址的指令
						0xff04   main  a  b 
						0xff78   func  a b c
						入栈操作  
						if(---)
ARM状态下	
	PC += 4；   0x 0   0000
				0x 4   0100
				0x 8   1000
				0x c   1100
		PC寄存器   ARM  [31:2]	字对齐	

	CPSR:  程序状态寄存器；记录CPU的当前状态；
		[4:0]CPU模式位： 标记当前CPU的模式，控制CPU模式 32个数  7种
			usr  10000    fiq  10001   svc  10011  abort 10111
			undef  11011  ...   irq   10010
			
			
		[7:6] i   f  中断控制位   fiq  irq 中断
		
		[31:28]  NZCV  条件位
		
		N：ALU中产生了负数的结果
		z：ALU中产生了0的结果
		c：加法时产生了进位C自动置1否则为0，减法时产生了借位C位自动置0否则为1
		V：对于有符号数符号位发生变化时自动置1
		
	SPSR :保存CPSR
		
		
ARM数据约定：
	字  	word    	32位    4字节
	半字    half word   16位    2字节
	字节    byte		8 位    内存的基本单位
	位      bit         1位

模式：
非特权模式：
1、usr 模式
特权模式
	异常模式
		2、SVC 
		3、abort
		4、IRQ
		5、FIQ
		6、undef	
	非异常模式
		7、system

何为异常？
不可预估的事件
	异常------------模式-----------异常向量表 
	复位：			svc             0x000000    pc   4字节   跳转指令
	未定义指令：	abord           0x000004   
	软中断：		svc             0x000008
	指令预取：      abord			0x00000C
	数据异常：		abord			0x000010
	保留：							0x000014
	中断：			irq           	0x000018
	快速中断：      fiq 			0x00001C       汇编
	
	
异常的处理：
	异常向量表：
		发生异常时，会自动跳转到对应地址执行代码。
	
异常的处理流程：,模式的切换和恢复
	硬件处理：（4大步）
		1、保存CPSR到对应模式下的spsr 
		2、设置CPSR（3小步）
			（1）、设置CPU位ARM状态   4字节对齐
			（2）、设置对应的模式位
			（3）、禁止某些中断，如果需要
		3、 保存（PC-4）到对应模式的LR中
		4、 设置PC为对应异常的地址
	
	软件处理：
		1、保存现场
			保存所有共用的寄存器，保存到当前模式的栈中（r0-r12,lr） 压栈； 
			
		2、处理异常
			
		3、恢复现场，返回
			（1）、弹栈，将保存的数据恢复
					恢复（r0-r12,PC）
			  (2)、恢复模式  SPSR  CPSR 
	
异常的优先级：
	复位 
	数据异常 
	快速中断：
	中断 
	指令预取异常
	软中断异常 
	指令异常 

快速中断比中断快的原因:
	1、优先级  			快速中断比中断优先级高
	2、寄存器数量： 	快速中断独立寄存器数量多，保存恢复时快
	3、异常向量位于向量表最后一个，可以不需要跳转而直接执行代码
	
流水线：提高代码执行效率

	指令的基本3个步骤：
	1、取址   
	2、译码
	3、执行
	
	
ARM指令：
	指令的格式：
	ARM汇编：     指令码<条件码>  <第一操作寄存器>  <第二操作寄存器>
	<opcode>{<code>}{s}   {<Rd>}, {<Rn>}, {<operand2>}
	
	3类指令：
		指令：实际会编译成机器码，一条机器码。
		伪指令：实际不能编译成一条机器码，但可以通过一些途径（多条机器码）来达到该目的。
		伪操作：不会生成机器码，告诉编译器，如何编译。
	
ARM汇编指令： 笔记在 start.s中
	数据搬移指令：
	
	所以指令都可以条件执行：
	
	
立即数：
	如果一个数，可以通过一个八位的数，循环右移偶数位得到，则该数是立即数。
	
0x 1280 0000  是立即数

0xF010 0000   不是立即数

0x3060 0000   不是立即数

0x1060 0000   不是立即数

有效数：
	某个数，取反后是一个立即数，这个这个数是有效数   包含立即数

0xffff ffff    0 

mvn 取反后再输入寄存器


	if（a < 0）
	{
		a = 10;
	}else
	{	
		b = 10;
	}
	
int buf[3],buf1[3]={1,2,3};
	int i;
	int *a=buf,*b=buf1;
	for(i=3;i>0;i--)
	{
		*a++ =*b++;
	}
	
	for(i=0;i<3;i++)
	{
		buf[i]=buf1[i];
	}

	多寄存器操作：  配对使用  IA - DB 
@ LDMIA / STMIA     Increment After   （先操作，后增加）  默认   *P++     满增
@ LDMIB / STMIB     Increment Before  （先增加，后操作）		*（++p）  空增
@ LDMDA / STMDA     Decrement After   （先操作，后递减）		*P--      满减
@ LDMDB / STMDB     Decrement Before  （先递减，后操作）		*（--p）  空减
	
栈操作指令：4个
	ldm  stm 
  @ FA:  Full Ascending       入栈  出栈  FA - FA 
  @ FD:  Full Descending
  @ EA:  Empty Ascending
  @ ED:  Empty Descending

  保存现场
  恢复现场
  
CPSR操作指令：
	mrs、msr 
1、取出cpsr到寄存器
2、设置cpsr
3、写入cpsr 
 
  
  
  
C编译器，使用的是满减栈
	汇编函数，
	汇编调用C函数
	C函数调用汇编
	
	
C汇编混合编程

	
	
	
	

