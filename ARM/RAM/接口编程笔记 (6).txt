                               
led2   output     驱动，函数     
void led_init(void);
void  led(unsigned char con,unsigned char ctr);   0001
unsigned char get_led_falg(void);

1、电路图：
	(1)\CPU  GPX2_7  引脚
	(2)  led2   亮   CPU输出高电平  1     0
	
2、芯片手册：
	(1)控制器，  GPIO控制器 
	(2)寄存器配置：
	
GPX2 ——7 
	控制寄存器  init
	GPX2CON    0x1100 0c40   32位
		[31:28]  = 0x1  输出模式
	
	
	*((unsigned int *)0x11000c40) = 
	a = (a & ~(0xf <<28)) | (1<<28);
	
	
	
	数据寄存器   使用
	GPX2DAT    0x1100 0c44   
		[7]      = 1  
	
	GPX2PUD   	0x1100 0c48   
		[15:14]  = 0    不使用上下拉

(3)、下载bin文件到开发板
	
执行 loadb 40008000    下载文件到内存0x40008000地址处
	使用 kermit协议下载文件

执行 go 40008000   执行下载的文件


input
设备   key2   led2 按键按下 灯亮  弹起灭

1、电路图：
	（1）、k2  按下 0  弹起高 1
	（2）、GPX1_1
	
2、芯片手册：
	CON   [7:4]   input 
	DAT
	PUD     0101

串口：
	通信，串行通信，并行通信
	
	波特率     9600   115200 bps   11.520    kb/s  
	数据位  	8位
	停止位      1,2,
	起始位
	校验位     奇偶校验   无
	
1\电路图： 
	CON7  ---  ttL rs232 互转芯片   ----   CPU  
		XuRXD2/UART_AUDIO_RXD/GPA1_0    
		XuTXD2/UART_AUDIO_TXD/GPA1_1    
	
	COM2   CH2
	RS232   +5V  -5V     ttl   +3.3V   0V 
	
2、芯片手册：
	
	配置GPIO控制器
	GPA1_0
	GPA1_1
		GPA1CON  [7:4]  0x2
				 [3:0]  0x2    
				 [7:0]  = 0x22
				 
	配置串口控制器
	ULCONn  
		[6] = 0   
		[5:3] = 000    无校验
		[2] = 0  1位停止位
		[1:0]  = 11  8位数据位    = 3
	
	UCONn 
		[3:2]  = 01  启用TX
		[1:0]  = 01  启用RX   [3:0] = 0x5
		
	UTRSTATn
		[2]   只读：  0 非空    1 空	  移位寄存器
		[1]   只读：  0 非空    1 空  * buf
		[0]   只读	  0 没有数据收到    1 收到数据    buf
	
	UTXHn 发送数据
		[7:0]
	
	URXHn  接收的数据
		[7:0]
	
	波特率配置    clock source 100M 
	UBRDIVn：   =  53 
	
	UFRACVALn： = 4 
	
	x = 100M /(115200 * 16 ) -1 
	
	x = 53.25347 
	
printf函数移植：

	1、格式化字符串,生成一个固定串
	2、调用puts函数  固定串 向串口 打印出来
	
	使用模板printf.tar.gz 

中断：
	硬件中断： 实时性设备
		GPIO    外部中断
		串口：  串口中断
		.....   ... 中断
	软件中断：
		信号
	
CPU 支持
	ARM CPU  siw  irq  fiq 
	
GIC中断控制器：
	1、扩展中断接口
	2、管理中断
	
SPI 共享中断源
	
	中断源表：   找到中断源与GIC的接口
	
寄存器： ICC 控制CPU接口层
		 ICD 端口管理层
	     总控制

1、电路图：		 
外部中断： CPU外部  GPIO中断
	key2     GPIO  GPX1_1 
	
	GIC  .....
	
	CPU  
	
2、芯片手册：
	GPIO控制器配置：
	1、GPX1CON[1]   		[7:4]   0xf  使能引脚为中断模式
	2、EXT_INT41_CON[1]    [6:4]   0x3  使能外部触发中断为上升沿触发模式   
	3、EXT_INT41_MASK[1] 	[1]     0    使能外部中断

	EXT_INT41_PEND[1]   [1]     中断挂起位，有中断发生时会自动置1

	GIC配置：
		端口管理层：
		GPX1_1  -  port   25    ID  57
		
		4、ICDDCR 总中断开关   [0]  = 1  使能总中断
		
		5、ICDISER1_CPU0    [25]    = 1  使能中断ID57进入CPU0
			规律：(端口号/32)   商，余数
			寄存器编号 = 1 + 商；
			寄存器bit范围  =  [余数]
		
		6、ICDIPR    优先级配置   为每个端口设置对应CPU的优先级   数字越小 优先级越高
			规律： (端口号/4)   商，余数
			寄存器编号 = 8 + 商；
			寄存器bit范围  =  [（余数+1）*8 -1   ---  余数*8]
			
			25    14  [15:8]   = 0x0
			ICDIPR14_CPU0
			
		7、ICDIPTR_CPU     配置中断源可以被哪个或哪些CPU相应
			
			规律： (端口号/4)   商，余数
			寄存器编号 = 8 + 商；
			寄存器bit范围  =  [（余数+1）*8 -1   ---  余数*8]
			25     14  [15:8]   = 0x1    CPU0 
		
		ICDICPR_CPU  GCI端口层 中断挂起    有中断发生时会自动置1
			ICDICPR1_CPU0   [25]     清除中断挂起：  = 1
		
	CPU管理层：

		8、ICCICR_CPUn  CPU 中断使能寄存器
			ICCICR_CPU0    [0] = 1;
			
		9、ICCPMR_CPU0  [7:0]  = 0xff  CPU 优先级过滤寄存器
			
			
		ICCIAR_CPU0     [9:0]  R   获取中断ID
		
		ICCEOIR_CPU0    中断结束寄存器，写入对应中断ID，表示该中断已经处理完成 

	软件中断处理流程：
		1、实现do_irq()函数，在START.S中调用，是异常处理函数
		2、清除中断挂起
			(1)\清除GPIO中断挂起
			(2)\清除GIC中断挂起
			(3)\结束中断，写入中断号到中断结束寄存器

	K3 GPX1_2      --P 26   ID 58
	K4 GPX3_2          32      64
		
看门狗控制器：
	看门狗定时器：
	
	复位：
	WTCON [15:8]  预分频值   实际分配 = 预分频值 + 1；
		[5] 看门狗使能位   1  使能 
		[4:3] 固定分频    16 32 64 128     00  01 10 11 
		[2]  中断使能位         0 
		[0]  复位信号使能位     1
		
	WTDAT 
		[15:0] ： 重载数据寄存器
	
	WTCNT 
		[15:0] 计数寄存器
	
	WTCLRINT 
		中断挂起寄存器
		
	1S  = 1  =  100M/ s /[16 32 64 128] / cnt  = 1 HZ
			s = ?    cnt ? 
			
			128    s * cnt = 781250 
			
			【1-256】  【0-65535】
			
			125   6250
			
			1S 
	
	WDT 中断工作模式   GIC端口43   中断号57 
	配置GIC控制器
	
PWM：
	波形的属性：
		1、周期和频率    
		2、占空比        有效电平与周期的比值

	PWM 脉宽调制器：
		调制方波的周期和占空比。
	
	蜂鸣器发声：
	GPD0_0    XpwmTOUT0   
	PWM 0 
	 
	
PWM蜂鸣器发声：
	配置GPIO控制器
	GPD0CON  [3:0]  = 0x2 PWMTOUT0
	
	PWM配置：
	TCFG0  [7:0]  预分频寄存器   0-0xff

	TCFG0  [15:8]   pwm 4
		   = 99
	
	TCFG1   [3:0]   MUX0   有5种选择  
		0000 = 1/1
		0001 = 1/2
		0010 = 1/4
		0011 = 1/8
		0100 = 1/16
	pwm 	
		[19:16]  = 0 
	
	TCON：
		[3]   = 1  使能自动重载
		[2]   = 1  使能波形输出
		[1]   = 1  使能TCNTB0 andTCMPB0 更新
		[0]        pwm启动1与停止0
	pwm4
		[22]  =  1  使能自动重载
		[21]  = 1 使能更新
		[20]    启停开关
		
		1Us   1MHZ    100M  / 100    =  1*100 
		
 	TCNTB0  [31:0]  计数寄存器（重载值）     影子寄存器（计数）

	0xffffffff
	
	TCMPB0  [31:0]  比较寄存器
	
	TCNTO0  观察寄存器

	F0 = PCLK/(预分频+1)/(固定分频)
	
	Fout = F0 / 重载寄存器；
	
	输出波形频率  = 100M /(预分频+1)/ (固定分频)/ 重载寄存器；
	输出波形占空比  =  比较值 / 重载值
	
	解得：
	(预分频+1) * (固定分频) * 重载寄存器 = 100M/ 50  2M 
		0		2
	(预分频+1) * 重载寄存器  = 1M 
	0-0xff       [31:0]
		0         1M = 1000000
	
假设50hz声音：
	
	Delay_ms(n);
	CH4 
	
ADC 模数转换器， 模拟量 - 数字量
	
	转换位数   10/12  
	参考电压   1.8V
	输入电压   0-1.8V
	
	点位器，0-1.8v    ADC3
	
ADCCON   
	[16]   = 1 选择12位ADC
	[15]   = 只读，转换完成标志   1  转换完成   0  正在转换
	[14]     预分频率使能位    	 =1  使能    0  
	[13:6]   预分频值    19 - 255      输入ADC时钟 不得超过 5M    19
	[2]    =  0  是ADC工作在正常模式
	[1]    =  1  读开始转换    0 不使用读开始
	[0]    手动启动开关  1 启动转换   
	
DATA
	[11:0]  转换结果
	
ADCMUX
	[3:0]   = 3 选择通道3
	
	1、配置
	2、启动转换  [0] = 1;
	3、等待转换完成    while([15] != 1);
	4、读取转换数据 
	    printf（）；
	延时 100ms
	goto  2
	
	
	us = 0xfffffffe + ... 9998 us   10 * 000
	
	us = 999  
	
	寄存器当前值  <  0xfffffffe  + 10 *1000 
	
	              < 9998 
	
	999   <   999 + 10 *1000   =   10999 
	



	PWM.TCFG0 = PWM.TCFG0 & (~(0xff))|0xf9;
	PWM.TCFG1 = PWM.TCFG1 & (~(0xf)) | 0x2;
	
	PWM.TCMPB0 = 25;
	PWM.TCNTB0 = 200;	
